{"ast":null,"code":"import { encode, decode } from \"@ethersproject/rlp\";\nimport { BigNumber } from \"bignumber.js\";\nexport function decodeTxInfo(rawTx) {\n  var VALID_TYPES = [1, 2];\n  var txType = VALID_TYPES.includes(rawTx[0]) ? rawTx[0] : null;\n  var rlpData = txType === null ? rawTx : rawTx.slice(1);\n  var rlpTx = decode(rlpData).map(function (hex) {\n    return Buffer.from(hex.slice(2), \"hex\");\n  });\n  var chainIdTruncated = 0;\n  var rlpDecoded = decode(rlpData);\n  var decodedTx;\n\n  if (txType === 2) {\n    // EIP1559\n    decodedTx = {\n      data: rlpDecoded[7],\n      to: rlpDecoded[5],\n      chainId: rlpTx[0]\n    };\n  } else if (txType === 1) {\n    // EIP2930\n    decodedTx = {\n      data: rlpDecoded[6],\n      to: rlpDecoded[4],\n      chainId: rlpTx[0]\n    };\n  } else {\n    // Legacy tx\n    decodedTx = {\n      data: rlpDecoded[5],\n      to: rlpDecoded[3],\n      // Default to 1 for non EIP 155 txs\n      chainId: rlpTx.length > 6 ? rlpTx[6] : Buffer.from(\"0x01\", \"hex\")\n    };\n  }\n\n  var chainIdSrc = decodedTx.chainId;\n  var chainId = new BigNumber(0);\n\n  if (chainIdSrc) {\n    // Using BigNumber because chainID could be any uint256.\n    chainId = new BigNumber(chainIdSrc.toString(\"hex\"), 16);\n    var chainIdTruncatedBuf = Buffer.alloc(4);\n\n    if (chainIdSrc.length > 4) {\n      chainIdSrc.copy(chainIdTruncatedBuf);\n    } else {\n      chainIdSrc.copy(chainIdTruncatedBuf, 4 - chainIdSrc.length);\n    }\n\n    chainIdTruncated = chainIdTruncatedBuf.readUInt32BE(0);\n  }\n\n  var vrsOffset = 0;\n\n  if (txType === null && rlpTx.length > 6) {\n    var rlpVrs = Buffer.from(encode(rlpTx.slice(-3)).slice(2), \"hex\");\n    vrsOffset = rawTx.length - (rlpVrs.length - 1); // First byte > 0xf7 means the length of the list length doesn't fit in a single byte.\n\n    if (rlpVrs[0] > 0xf7) {\n      // Increment vrsOffset to account for that extra byte.\n      vrsOffset++; // Compute size of the list length.\n\n      var sizeOfListLen = rlpVrs[0] - 0xf7; // Increase rlpOffset by the size of the list length.\n\n      vrsOffset += sizeOfListLen - 1;\n    }\n  }\n\n  return {\n    decodedTx: decodedTx,\n    txType: txType,\n    chainId: chainId,\n    chainIdTruncated: chainIdTruncated,\n    vrsOffset: vrsOffset\n  };\n}","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { encode, decode } from \"@ethersproject/rlp\";\nimport { BigNumber } from \"bignumber.js\";\nexport function decodeTxInfo(rawTx) {\n    var VALID_TYPES = [1, 2];\n    var txType = VALID_TYPES.includes(rawTx[0]) ? rawTx[0] : null;\n    var rlpData = txType === null ? rawTx : rawTx.slice(1);\n    var rlpTx = decode(rlpData).map(function (hex) { return Buffer.from(hex.slice(2), \"hex\"); });\n    var chainIdTruncated = 0;\n    var rlpDecoded = decode(rlpData);\n    var decodedTx;\n    if (txType === 2) {\n        // EIP1559\n        decodedTx = {\n            data: rlpDecoded[7],\n            to: rlpDecoded[5],\n            chainId: rlpTx[0]\n        };\n    }\n    else if (txType === 1) {\n        // EIP2930\n        decodedTx = {\n            data: rlpDecoded[6],\n            to: rlpDecoded[4],\n            chainId: rlpTx[0]\n        };\n    }\n    else {\n        // Legacy tx\n        decodedTx = {\n            data: rlpDecoded[5],\n            to: rlpDecoded[3],\n            // Default to 1 for non EIP 155 txs\n            chainId: rlpTx.length > 6 ? rlpTx[6] : Buffer.from(\"0x01\", \"hex\")\n        };\n    }\n    var chainIdSrc = decodedTx.chainId;\n    var chainId = new BigNumber(0);\n    if (chainIdSrc) {\n        // Using BigNumber because chainID could be any uint256.\n        chainId = new BigNumber(chainIdSrc.toString(\"hex\"), 16);\n        var chainIdTruncatedBuf = Buffer.alloc(4);\n        if (chainIdSrc.length > 4) {\n            chainIdSrc.copy(chainIdTruncatedBuf);\n        }\n        else {\n            chainIdSrc.copy(chainIdTruncatedBuf, 4 - chainIdSrc.length);\n        }\n        chainIdTruncated = chainIdTruncatedBuf.readUInt32BE(0);\n    }\n    var vrsOffset = 0;\n    if (txType === null && rlpTx.length > 6) {\n        var rlpVrs = Buffer.from(encode(rlpTx.slice(-3)).slice(2), \"hex\");\n        vrsOffset = rawTx.length - (rlpVrs.length - 1);\n        // First byte > 0xf7 means the length of the list length doesn't fit in a single byte.\n        if (rlpVrs[0] > 0xf7) {\n            // Increment vrsOffset to account for that extra byte.\n            vrsOffset++;\n            // Compute size of the list length.\n            var sizeOfListLen = rlpVrs[0] - 0xf7;\n            // Increase rlpOffset by the size of the list length.\n            vrsOffset += sizeOfListLen - 1;\n        }\n    }\n    return {\n        decodedTx: decodedTx,\n        txType: txType,\n        chainId: chainId,\n        chainIdTruncated: chainIdTruncated,\n        vrsOffset: vrsOffset\n    };\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}