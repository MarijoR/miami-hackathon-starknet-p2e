{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.crypto = exports.wrapHash = exports.equalsBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.hexToBytes = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0; // buf.toString('hex') -> toHex(buf)\n\nconst utils_1 = require(\"@noble/hashes/utils\");\n\nvar utils_2 = require(\"@noble/hashes/utils\");\n\nObject.defineProperty(exports, \"assertBool\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.assertBool;\n  }\n});\nObject.defineProperty(exports, \"assertBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.assertBytes;\n  }\n});\nObject.defineProperty(exports, \"bytesToHex\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.bytesToHex;\n  }\n});\nObject.defineProperty(exports, \"toHex\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.bytesToHex;\n  }\n});\nObject.defineProperty(exports, \"concatBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.concatBytes;\n  }\n});\nObject.defineProperty(exports, \"hexToBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.hexToBytes;\n  }\n});\nObject.defineProperty(exports, \"createView\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.createView;\n  }\n});\nObject.defineProperty(exports, \"utf8ToBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.utf8ToBytes;\n  }\n}); // buf.toString('utf8') -> bytesToUtf8(buf)\n\nfunction bytesToUtf8(data) {\n  if (!(data instanceof Uint8Array)) {\n    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);\n  }\n\n  return new TextDecoder().decode(data);\n}\n\nexports.bytesToUtf8 = bytesToUtf8; // buf.equals(buf2) -> equalsBytes(buf, buf2)\n\nfunction equalsBytes(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.equalsBytes = equalsBytes; // Internal utils\n\nfunction wrapHash(hash) {\n  return msg => {\n    (0, utils_1.assertBytes)(msg);\n    return hash(msg);\n  };\n}\n\nexports.wrapHash = wrapHash;\n\nexports.crypto = (() => {\n  const webCrypto = typeof self === \"object\" && \"crypto\" in self ? self.crypto : undefined;\n\n  const nodeRequire = typeof module !== \"undefined\" && typeof module.require === \"function\" && module.require.bind(module);\n\n  return {\n    node: nodeRequire && !webCrypto ? nodeRequire(\"crypto\") : undefined,\n    web: webCrypto\n  };\n})();","map":{"version":3,"sources":["src/utils.ts"],"names":[],"mappings":";;;;;8PAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AACE,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA;EAAA,UAAA,EAAA,IAAA;EAAA,GAAA,EAAA,YAAA;IAAA,OAAA,OAAA,CAAA,UAAA;EAAU;AAAV,CAAA;AACA,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,aAAA,EAAA;EAAA,UAAA,EAAA,IAAA;EAAA,GAAA,EAAA,YAAA;IAAA,OAAA,OAAA,CAAA,WAAA;EAAW;AAAX,CAAA;AACA,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA;EAAA,UAAA,EAAA,IAAA;EAAA,GAAA,EAAA,YAAA;IAAA,OAAA,OAAA,CAAA,UAAA;EAAU;AAAV,CAAA;AACA,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,OAAA,EAAA;EAAA,UAAA,EAAA,IAAA;EAAA,GAAA,EAAA,YAAA;IAAA,OAAA,OAAA,CAAA,UAAA;EAAU;AAAV,CAAA;AACA,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,aAAA,EAAA;EAAA,UAAA,EAAA,IAAA;EAAA,GAAA,EAAA,YAAA;IAAA,OAAA,OAAA,CAAA,WAAA;EAAW;AAAX,CAAA;AACA,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA;EAAA,UAAA,EAAA,IAAA;EAAA,GAAA,EAAA,YAAA;IAAA,OAAA,OAAA,CAAA,UAAA;EAAU;AAAV,CAAA;AACA,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA;EAAA,UAAA,EAAA,IAAA;EAAA,GAAA,EAAA,YAAA;IAAA,OAAA,OAAA,CAAA,UAAA;EAAU;AAAV,CAAA;AACA,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,aAAA,EAAA;EAAA,UAAA,EAAA,IAAA;EAAA,GAAA,EAAA,YAAA;IAAA,OAAA,OAAA,CAAA,WAAA;EAAW;AAAX,CAAA,E,CAGF;;AACA,SAAgB,WAAhB,CAA4B,IAA5B,EAA4C;EAC1C,IAAI,EAAE,IAAI,YAAY,UAAlB,CAAJ,EAAmC;IACjC,MAAM,IAAI,SAAJ,CAAc,wCAAwC,OAAO,IAAI,EAAjE,CAAN;EACD;;EACD,OAAO,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,IAAzB,CAAP;AACD;;AALD,OAAA,CAAA,WAAA,GAAA,WAAA,C,CAOA;;AACA,SAAgB,WAAhB,CAA4B,CAA5B,EAA2C,CAA3C,EAAwD;EACtD,IAAI,CAAC,CAAC,MAAF,KAAa,CAAC,CAAC,MAAnB,EAA2B;IACzB,OAAO,KAAP;EACD;;EACD,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAAC,CAAC,MAAtB,EAA8B,CAAC,EAA/B,EAAmC;IACjC,IAAI,CAAC,CAAC,CAAD,CAAD,KAAS,CAAC,CAAC,CAAD,CAAd,EAAmB;MACjB,OAAO,KAAP;IACD;EACF;;EACD,OAAO,IAAP;AACD;;AAVD,OAAA,CAAA,WAAA,GAAA,WAAA,C,CAYA;;AACA,SAAgB,QAAhB,CAAyB,IAAzB,EAA8D;EAC5D,OAAQ,GAAD,IAAoB;IACzB,CAAA,GAAA,OAAA,CAAA,WAAA,EAAY,GAAZ;IACA,OAAO,IAAI,CAAC,GAAD,CAAX;EACD,CAHD;AAID;;AALD,OAAA,CAAA,QAAA,GAAA,QAAA;;AAOa,OAAA,CAAA,MAAA,GAAuC,CAAC,MAAK;EACxD,MAAM,SAAS,GACb,OAAO,IAAP,KAAgB,QAAhB,IAA4B,YAAY,IAAxC,GAA+C,IAAI,CAAC,MAApD,GAA6D,SAD/D;;EAEA,MAAM,WAAW,GACf,OAAO,MAAP,KAAkB,WAAlB,IACA,OAAO,MAAM,CAAC,OAAd,KAA0B,UAD1B,IAEA,MAAM,CAAC,OAAP,CAAe,IAAf,CAAoB,MAApB,CAHF;;EAIA,OAAO;IACL,IAAI,EAAE,WAAW,IAAI,CAAC,SAAhB,GAA4B,WAAW,CAAC,QAAD,CAAvC,GAAoD,SADrD;IAEL,GAAG,EAAE;EAFA,CAAP;AAID,CAXmD,GAAvC","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.crypto = exports.wrapHash = exports.equalsBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.hexToBytes = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;\n// buf.toString('hex') -> toHex(buf)\nconst utils_1 = require(\"@noble/hashes/utils\");\nvar utils_2 = require(\"@noble/hashes/utils\");\nObject.defineProperty(exports, \"assertBool\", { enumerable: true, get: function () { return utils_2.assertBool; } });\nObject.defineProperty(exports, \"assertBytes\", { enumerable: true, get: function () { return utils_2.assertBytes; } });\nObject.defineProperty(exports, \"bytesToHex\", { enumerable: true, get: function () { return utils_2.bytesToHex; } });\nObject.defineProperty(exports, \"toHex\", { enumerable: true, get: function () { return utils_2.bytesToHex; } });\nObject.defineProperty(exports, \"concatBytes\", { enumerable: true, get: function () { return utils_2.concatBytes; } });\nObject.defineProperty(exports, \"hexToBytes\", { enumerable: true, get: function () { return utils_2.hexToBytes; } });\nObject.defineProperty(exports, \"createView\", { enumerable: true, get: function () { return utils_2.createView; } });\nObject.defineProperty(exports, \"utf8ToBytes\", { enumerable: true, get: function () { return utils_2.utf8ToBytes; } });\n// buf.toString('utf8') -> bytesToUtf8(buf)\nfunction bytesToUtf8(data) {\n    if (!(data instanceof Uint8Array)) {\n        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);\n    }\n    return new TextDecoder().decode(data);\n}\nexports.bytesToUtf8 = bytesToUtf8;\n// buf.equals(buf2) -> equalsBytes(buf, buf2)\nfunction equalsBytes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.equalsBytes = equalsBytes;\n// Internal utils\nfunction wrapHash(hash) {\n    return (msg) => {\n        (0, utils_1.assertBytes)(msg);\n        return hash(msg);\n    };\n}\nexports.wrapHash = wrapHash;\nexports.crypto = (() => {\n    const webCrypto = typeof self === \"object\" && \"crypto\" in self ? self.crypto : undefined;\n    const nodeRequire = typeof module !== \"undefined\" &&\n        typeof module.require === \"function\" &&\n        module.require.bind(module);\n    return {\n        node: nodeRequire && !webCrypto ? nodeRequire(\"crypto\") : undefined,\n        web: webCrypto\n    };\n})();\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}