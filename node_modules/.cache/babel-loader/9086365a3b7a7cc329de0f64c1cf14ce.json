{"ast":null,"code":"/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n  constructor(failure, failures) {\n    let cached;\n    const {\n      message,\n      ...rest\n    } = failure;\n    const {\n      path\n    } = failure;\n    const msg = path.length === 0 ? message : \"At path: \" + path.join('.') + \" -- \" + message;\n    super(msg);\n    this.value = void 0;\n    this.key = void 0;\n    this.type = void 0;\n    this.refinement = void 0;\n    this.path = void 0;\n    this.branch = void 0;\n    this.failures = void 0;\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n\n    this.failures = () => {\n      var _cached;\n\n      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];\n    };\n  }\n\n}\n/**\n * Check if a value is an iterator.\n */\n\n\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\n\n\nfunction isObject(x) {\n  return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\n\n\nfunction isPlainObject(x) {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(x);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\n\n\nfunction print(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\n\nfunction shiftIterator(input) {\n  const {\n    done,\n    value\n  } = input.next();\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\n\n\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n\n  const {\n    path,\n    branch\n  } = context;\n  const {\n    type\n  } = struct;\n  const {\n    refinement,\n    message = \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : '') + \", but received: `\" + print(value) + \"`\"\n  } = result;\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message\n  };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\n\n\nfunction* toFailures(result, context, struct, value) {\n  if (!isIterable(result)) {\n    result = [result];\n  }\n\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value);\n\n    if (failure) {\n      yield failure;\n    }\n  }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\n\nfunction* run(value, struct) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    path = [],\n    branch = [value],\n    coerce = false,\n    mask = false\n  } = options;\n  const ctx = {\n    path,\n    branch\n  };\n\n  if (coerce) {\n    value = struct.coercer(value, ctx);\n\n    if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key];\n        }\n      }\n    }\n  }\n\n  let valid = true;\n\n  for (const failure of struct.validator(value, ctx)) {\n    valid = false;\n    yield [failure, undefined];\n  }\n\n  for (let [k, v, s] of struct.entries(value, ctx)) {\n    const ts = run(v, s, {\n      path: k === undefined ? path : [...path, k],\n      branch: k === undefined ? branch : [...branch, v],\n      coerce,\n      mask\n    });\n\n    for (const t of ts) {\n      if (t[0]) {\n        valid = false;\n        yield [t[0], undefined];\n      } else if (coerce) {\n        v = t[1];\n\n        if (k === undefined) {\n          value = v;\n        } else if (value instanceof Map) {\n          value.set(k, v);\n        } else if (value instanceof Set) {\n          value.add(v);\n        } else if (isObject(value)) {\n          value[k] = v;\n        }\n      }\n    }\n  }\n\n  if (valid) {\n    for (const failure of struct.refiner(value, ctx)) {\n      valid = false;\n      yield [failure, undefined];\n    }\n  }\n\n  if (valid) {\n    yield [undefined, value];\n  }\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\n\nclass Struct {\n  constructor(props) {\n    this.TYPE = void 0;\n    this.type = void 0;\n    this.schema = void 0;\n    this.coercer = void 0;\n    this.validator = void 0;\n    this.refiner = void 0;\n    this.entries = void 0;\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = value => value,\n      entries = function* () {}\n    } = props;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.validator = () => [];\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.refiner = () => [];\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n\n  assert(value) {\n    return assert(value, this);\n  }\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n\n  create(value) {\n    return create(value, this);\n  }\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n\n  is(value) {\n    return is(value, this);\n  }\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n\n  mask(value) {\n    return mask(value, this);\n  }\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n\n  validate(value) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return validate(value, this, options);\n  }\n\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\n\nfunction assert(value, struct) {\n  const result = validate(value, struct);\n\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\n\nfunction create(value, struct) {\n  const result = validate(value, struct, {\n    coerce: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\n\nfunction mask(value, struct) {\n  const result = validate(value, struct, {\n    coerce: true,\n    mask: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Check if a value passes a struct.\n */\n\n\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\n\nfunction validate(value, struct) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const tuples = run(value, struct, options);\n  const tuple = shiftIterator(tuples);\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0];\n        }\n      }\n    });\n    return [error, undefined];\n  } else {\n    const v = tuple[1];\n    return [undefined, v];\n  }\n}\n\nfunction assign() {\n  for (var _len = arguments.length, Structs = new Array(_len), _key = 0; _key < _len; _key++) {\n    Structs[_key] = arguments[_key];\n  }\n\n  const isType = Structs[0].type === 'type';\n  const schemas = Structs.map(s => s.schema);\n  const schema = Object.assign({}, ...schemas);\n  return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\n\n\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator\n  });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\n\n\nfunction deprecated(struct, log) {\n  return new Struct({ ...struct,\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true;\n      } else {\n        log(value, ctx);\n        return struct.validator(value, ctx);\n      }\n    }\n\n  });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\n\nfunction dynamic(fn) {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n\n    *entries(value, ctx) {\n      const struct = fn(value, ctx);\n      yield* struct.entries(value, ctx);\n    },\n\n    validator(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n\n    coercer(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    },\n\n    refiner(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.refiner(value, ctx);\n    }\n\n  });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\n\nfunction lazy(fn) {\n  let struct;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n\n    *entries(value, ctx) {\n      var _struct;\n\n      (_struct = struct) != null ? _struct : struct = fn();\n      yield* struct.entries(value, ctx);\n    },\n\n    validator(value, ctx) {\n      var _struct2;\n\n      (_struct2 = struct) != null ? _struct2 : struct = fn();\n      return struct.validator(value, ctx);\n    },\n\n    coercer(value, ctx) {\n      var _struct3;\n\n      (_struct3 = struct) != null ? _struct3 : struct = fn();\n      return struct.coercer(value, ctx);\n    },\n\n    refiner(value, ctx) {\n      var _struct4;\n\n      (_struct4 = struct) != null ? _struct4 : struct = fn();\n      return struct.refiner(value, ctx);\n    }\n\n  });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\n\nfunction omit(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = { ...schema\n  };\n\n  for (const key of keys) {\n    delete subschema[key];\n  }\n\n  switch (struct.type) {\n    case 'type':\n      return type(subschema);\n\n    default:\n      return object(subschema);\n  }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\n\nfunction partial(struct) {\n  const schema = struct instanceof Struct ? { ...struct.schema\n  } : { ...struct\n  };\n\n  for (const key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n\n  return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\n\nfunction pick(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = {};\n\n  for (const key of keys) {\n    subschema[key] = schema[key];\n  }\n\n  return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\n\nfunction struct(name, validator) {\n  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n  return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */\n\n\nfunction any() {\n  return define('any', () => true);\n}\n\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element];\n        }\n      }\n    },\n\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a bigint.\n */\n\n\nfunction bigint() {\n  return define('bigint', value => {\n    return typeof value === 'bigint';\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\n\n\nfunction boolean() {\n  return define('boolean', value => {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\n\nfunction date() {\n  return define('date', value => {\n    return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n  });\n}\n\nfunction enums(values) {\n  const schema = {};\n  const description = values.map(v => print(v)).join();\n\n  for (const key of values) {\n    schema[key] = key;\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n\n    validator(value) {\n      return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a function.\n */\n\n\nfunction func() {\n  return define('func', value => {\n    return typeof value === 'function' || \"Expected a function, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\n\nfunction instance(Class) {\n  return define('instance', value => {\n    return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an integer.\n */\n\n\nfunction integer() {\n  return define('integer', value => {\n    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\n\n\nfunction intersection(Structs) {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx);\n      }\n    },\n\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx);\n      }\n    },\n\n    *refiner(value, ctx) {\n      for (const S of Structs) {\n        yield* S.refiner(value, ctx);\n      }\n    }\n\n  });\n}\n\nfunction literal(constant) {\n  const description = print(constant);\n  const t = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n\n    validator(value) {\n      return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n    }\n\n  });\n}\n\nfunction map(Key, Value) {\n  return new Struct({\n    type: 'map',\n    schema: null,\n\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n\n    validator(value) {\n      return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that no value ever passes validation.\n */\n\n\nfunction never() {\n  return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\n\n\nfunction nullable(struct) {\n  return new Struct({ ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is a number.\n */\n\n\nfunction number() {\n  return define('number', value => {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n  });\n}\n\nfunction object(schema) {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value));\n\n        for (const key of knowns) {\n          unknowns.delete(key);\n          yield [key, value[key], schema[key]];\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    },\n\n    coercer(value) {\n      return isObject(value) ? { ...value\n      } : value;\n    }\n\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\n\n\nfunction optional(struct) {\n  return new Struct({ ...struct,\n    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\n\nfunction record(Key, Value) {\n  return new Struct({\n    type: 'record',\n    schema: null,\n\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k];\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\n\nfunction regexp() {\n  return define('regexp', value => {\n    return value instanceof RegExp;\n  });\n}\n\nfunction set(Element) {\n  return new Struct({\n    type: 'set',\n    schema: null,\n\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v, v, Element];\n        }\n      }\n    },\n\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n\n    validator(value) {\n      return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a string.\n */\n\n\nfunction string() {\n  return define('string', value => {\n    return typeof value === 'string' || \"Expected a string, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\n\n\nfunction tuple(Structs) {\n  const Never = never();\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Structs.length, value.length);\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Structs[i] || Never];\n        }\n      }\n    },\n\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\n\nfunction type(schema) {\n  const keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema,\n\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\n\n\nfunction union(Structs) {\n  const description = Structs.map(s => s.type).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n\n    coercer(value, ctx) {\n      const firstMatch = Structs.find(s => {\n        const [e] = s.validate(value, {\n          coerce: true\n        });\n        return !e;\n      }) || unknown();\n      return firstMatch.coercer(value, ctx);\n    },\n\n    validator(value, ctx) {\n      const failures = [];\n\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx);\n        const [first] = tuples;\n\n        if (!first[0]) {\n          return [];\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure);\n            }\n          }\n        }\n      }\n\n      return [\"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value), ...failures];\n    }\n\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\n\nfunction unknown() {\n  return define('unknown', () => true);\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\n\nfunction coerce(struct, condition, coercer) {\n  return new Struct({ ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\n\nfunction defaulted(struct, fallback) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return coerce(struct, unknown(), x => {\n    const f = typeof fallback === 'function' ? fallback() : fallback;\n\n    if (x === undefined) {\n      return f;\n    }\n\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x\n      };\n      let changed = false;\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        return ret;\n      }\n    }\n\n    return x;\n  });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\n\nfunction trimmed(struct) {\n  return coerce(struct, string(), x => x.trim());\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\n\nfunction empty(struct) {\n  return refine(struct, 'empty', value => {\n    const size = getSize(value);\n    return size === 0 || \"Expected an empty \" + struct.type + \" but received one with a size of `\" + size + \"`\";\n  });\n}\n\nfunction getSize(value) {\n  if (value instanceof Map || value instanceof Set) {\n    return value.size;\n  } else {\n    return value.length;\n  }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\n\n\nfunction max(struct, threshold) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'max', value => {\n    return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" less than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\n\n\nfunction min(struct, threshold) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'min', value => {\n    return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\n\n\nfunction nonempty(struct) {\n  return refine(struct, 'nonempty', value => {\n    const size = getSize(value);\n    return size > 0 || \"Expected a nonempty \" + struct.type + \" but received an empty one\";\n  });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\n\nfunction pattern(struct, regexp) {\n  return refine(struct, 'pattern', value => {\n    return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + \"/` but received \\\"\" + value + \"\\\"\";\n  });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\n\nfunction size(struct, min) {\n  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : min;\n  const expected = \"Expected a \" + struct.type;\n  const of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n  return refine(struct, 'size', value => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n    } else if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return min <= size && size <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + size + \"`\";\n    } else {\n      const {\n        length\n      } = value;\n      return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\n\nfunction refine(struct, name, refiner) {\n  return new Struct({ ...struct,\n\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx);\n      const result = refiner(value, ctx);\n      const failures = toFailures(result, ctx, struct, value);\n\n      for (const failure of failures) {\n        yield { ...failure,\n          refinement: name\n        };\n      }\n    }\n\n  });\n}\n\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };","map":{"version":3,"sources":["../src/error.ts","../src/utils.ts","../src/struct.ts","../src/structs/utilities.ts","../src/structs/types.ts","../src/structs/coercions.ts","../src/structs/refinements.ts"],"names":["StructError","TypeError","value","key","type","refinement","path","branch","failures","constructor","failure","rest","msg","Object","cached","isObject","x","Symbol","isPlainObject","prototype","print","JSON","shiftIterator","input","done","toFailure","result","context","struct","message","toFailures","isIterable","run","options","coerce","mask","ctx","Array","valid","ts","k","t","v","Struct","TYPE","schema","coercer","validator","refiner","entries","props","assert","create","is","validate","tuples","tuple","error","assign","Structs","isType","schemas","s","object","define","name","deprecated","log","dynamic","fn","lazy","omit","keys","subschema","partial","optional","pick","console","any","array","Element","bigint","boolean","date","isNaN","enums","values","description","func","instance","Class","integer","Number","intersection","S","literal","constant","map","Key","Value","never","nullable","number","knowns","Never","unknowns","record","regexp","set","string","length","Math","i","union","firstMatch","unknown","first","condition","defaulted","fallback","f","ret","changed","trimmed","empty","refine","size","getSize","max","threshold","exclusive","min","nonempty","pattern","expected","of"],"mappings":"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","sourcesContent":["/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\nexport type Failure = {\n  value: any\n  key: any\n  type: string\n  refinement: string | undefined\n  message: string\n  branch: Array<any>\n  path: Array<any>\n}\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\n\nexport class StructError extends TypeError {\n  value: any\n  key!: any\n  type!: string\n  refinement!: string | undefined\n  path!: Array<any>\n  branch!: Array<any>\n  failures: () => Array<Failure>;\n  [x: string]: any\n\n  constructor(failure: Failure, failures: () => Generator<Failure>) {\n    let cached: Array<Failure> | undefined\n    const { message, ...rest } = failure\n    const { path } = failure\n    const msg =\n      path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`\n    super(msg)\n    Object.assign(this, rest)\n    this.name = this.constructor.name\n    this.failures = () => {\n      return (cached ??= [failure, ...failures()])\n    }\n  }\n}\n","import { Struct, Infer, Result, Context, Describe } from './struct'\nimport { Failure } from './error'\n\n/**\n * Check if a value is an iterator.\n */\n\nfunction isIterable<T>(x: unknown): x is Iterable<T> {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function'\n}\n\n/**\n * Check if a value is a plain object.\n */\n\nexport function isObject(x: unknown): x is object {\n  return typeof x === 'object' && x != null\n}\n\n/**\n * Check if a value is a plain object.\n */\n\nexport function isPlainObject(x: unknown): x is { [key: string]: any } {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(x)\n  return prototype === null || prototype === Object.prototype\n}\n\n/**\n * Return a value as a printable string.\n */\n\nexport function print(value: any): string {\n  return typeof value === 'string' ? JSON.stringify(value) : `${value}`\n}\n\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nexport function shiftIterator<T>(input: Iterator<T>): T | undefined {\n  const { done, value } = input.next()\n  return done ? undefined : value\n}\n\n/**\n * Convert a single validation result to a failure.\n */\n\nexport function toFailure<T, S>(\n  result: string | boolean | Partial<Failure>,\n  context: Context,\n  struct: Struct<T, S>,\n  value: any\n): Failure | undefined {\n  if (result === true) {\n    return\n  } else if (result === false) {\n    result = {}\n  } else if (typeof result === 'string') {\n    result = { message: result }\n  }\n\n  const { path, branch } = context\n  const { type } = struct\n  const {\n    refinement,\n    message = `Expected a value of type \\`${type}\\`${\n      refinement ? ` with refinement \\`${refinement}\\`` : ''\n    }, but received: \\`${print(value)}\\``,\n  } = result\n\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message,\n  }\n}\n\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nexport function* toFailures<T, S>(\n  result: Result,\n  context: Context,\n  struct: Struct<T, S>,\n  value: any\n): IterableIterator<Failure> {\n  if (!isIterable(result)) {\n    result = [result]\n  }\n\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value)\n\n    if (failure) {\n      yield failure\n    }\n  }\n}\n\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\nexport function* run<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  options: {\n    path?: any[]\n    branch?: any[]\n    coerce?: boolean\n    mask?: boolean\n  } = {}\n): IterableIterator<[Failure, undefined] | [undefined, T]> {\n  const { path = [], branch = [value], coerce = false, mask = false } = options\n  const ctx: Context = { path, branch }\n\n  if (coerce) {\n    value = struct.coercer(value, ctx)\n\n    if (\n      mask &&\n      struct.type !== 'type' &&\n      isObject(struct.schema) &&\n      isObject(value) &&\n      !Array.isArray(value)\n    ) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key]\n        }\n      }\n    }\n  }\n\n  let valid = true\n\n  for (const failure of struct.validator(value, ctx)) {\n    valid = false\n    yield [failure, undefined]\n  }\n\n  for (let [k, v, s] of struct.entries(value, ctx)) {\n    const ts = run(v, s as Struct, {\n      path: k === undefined ? path : [...path, k],\n      branch: k === undefined ? branch : [...branch, v],\n      coerce,\n      mask,\n    })\n\n    for (const t of ts) {\n      if (t[0]) {\n        valid = false\n        yield [t[0], undefined]\n      } else if (coerce) {\n        v = t[1]\n\n        if (k === undefined) {\n          value = v\n        } else if (value instanceof Map) {\n          value.set(k, v)\n        } else if (value instanceof Set) {\n          value.add(v)\n        } else if (isObject(value)) {\n          value[k] = v\n        }\n      }\n    }\n  }\n\n  if (valid) {\n    for (const failure of struct.refiner(value as T, ctx)) {\n      valid = false\n      yield [failure, undefined]\n    }\n  }\n\n  if (valid) {\n    yield [undefined, value as T]\n  }\n}\n\n/**\n * Convert a union of type to an intersection.\n */\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (arg: U) => any : never\n) extends (arg: infer I) => void\n  ? I\n  : never\n\n/**\n * Assign properties from one type to another, overwriting existing.\n */\n\nexport type Assign<T, U> = Simplify<U & Omit<T, keyof U>>\n\n/**\n * A schema for enum structs.\n */\n\nexport type EnumSchema<T extends string | number | undefined> = {\n  [K in NonNullable<T>]: K\n}\n\n/**\n * Check if a type is a match for another whilst treating overlapping\n * unions as a match.\n */\n\nexport type IsMatch<T, G> = T extends G ? (G extends T ? T : never) : never\n\n/**\n * Check if a type is an exact match.\n */\n\nexport type IsExactMatch<T, U> = (<G>() => G extends T ? 1 : 2) extends <\n  G\n>() => G extends U ? 1 : 2\n  ? T\n  : never\n\n/**\n * Check if a type is a record type.\n */\n\nexport type IsRecord<T> = T extends object\n  ? string extends keyof T\n    ? T\n    : never\n  : never\n/**\n * Check if a type is a tuple.\n */\n\nexport type IsTuple<T> = T extends [any]\n  ? T\n  : T extends [any, any]\n  ? T\n  : T extends [any, any, any]\n  ? T\n  : T extends [any, any, any, any]\n  ? T\n  : T extends [any, any, any, any, any]\n  ? T\n  : never\n\n/**\n * Check if a type is a union.\n */\n\nexport type IsUnion<T, U extends T = T> = (\n  T extends any ? (U extends T ? false : true) : false\n) extends false\n  ? never\n  : T\n\n/**\n * A schema for object structs.\n */\n\nexport type ObjectSchema = Record<string, Struct<any, any>>\n\n/**\n * Infer a type from an object struct schema.\n */\n\nexport type ObjectType<S extends ObjectSchema> = Simplify<\n  Optionalize<{ [K in keyof S]: Infer<S[K]> }>\n>\n\n/**\n * Omit properties from a type that extend from a specific type.\n */\n\nexport type OmitBy<T, V> = Omit<\n  T,\n  { [K in keyof T]: V extends Extract<T[K], V> ? K : never }[keyof T]\n>\n\n/**\n * Normalize properties of a type that allow `undefined` to make them optional.\n */\n\nexport type Optionalize<S extends object> = OmitBy<S, undefined> &\n  Partial<PickBy<S, undefined>>\n\n/**\n * Transform an object schema type to represent a partial.\n */\n\nexport type PartialObjectSchema<S extends ObjectSchema> = {\n  [K in keyof S]: Struct<Infer<S[K]> | undefined>\n}\n\n/**\n * Pick properties from a type that extend from a specific type.\n */\n\nexport type PickBy<T, V> = Pick<\n  T,\n  { [K in keyof T]: V extends Extract<T[K], V> ? K : never }[keyof T]\n>\n\n/**\n * Simplifies a type definition to its most basic representation.\n */\n\nexport type Simplify<T> = T extends any[] | Date\n  ? T\n  : { [K in keyof T]: T[K] } & {}\n\nexport type If<B extends Boolean, Then, Else> = B extends true ? Then : Else\n\n/**\n * A schema for any type of struct.\n */\n\nexport type StructSchema<T> = [T] extends [string | undefined]\n  ? [T] extends [IsMatch<T, string | undefined>]\n    ? null\n    : [T] extends [IsUnion<T>]\n    ? EnumSchema<T>\n    : T\n  : [T] extends [number | undefined]\n  ? [T] extends [IsMatch<T, number | undefined>]\n    ? null\n    : [T] extends [IsUnion<T>]\n    ? EnumSchema<T>\n    : T\n  : [T] extends [boolean]\n  ? [T] extends [IsExactMatch<T, boolean>]\n    ? null\n    : T\n  : T extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : T extends Array<infer E>\n  ? T extends IsTuple<T>\n    ? null\n    : Struct<E>\n  : T extends object\n  ? T extends IsRecord<T>\n    ? null\n    : { [K in keyof T]: Describe<T[K]> }\n  : null\n\n/**\n * A schema for tuple structs.\n */\n\nexport type TupleSchema<T> = { [K in keyof T]: Struct<T[K]> }\n\n/**\n * Shorthand type for matching any `Struct`.\n */\n\nexport type AnyStruct = Struct<any, any>\n\n/**\n * Infer a tuple of types from a tuple of `Struct`s.\n *\n * This is used to recursively retrieve the type from `union` `intersection` and\n * `tuple` structs.\n */\n\nexport type InferStructTuple<\n  Tuple extends AnyStruct[],\n  Length extends number = Tuple['length']\n> = Length extends Length\n  ? number extends Length\n    ? Tuple\n    : _InferTuple<Tuple, Length, []>\n  : never\ntype _InferTuple<\n  Tuple extends AnyStruct[],\n  Length extends number,\n  Accumulated extends unknown[],\n  Index extends number = Accumulated['length']\n> = Index extends Length\n  ? Accumulated\n  : _InferTuple<Tuple, Length, [...Accumulated, Infer<Tuple[Index]>]>\n","import { toFailures, shiftIterator, StructSchema, run } from './utils'\nimport { StructError, Failure } from './error'\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\nexport class Struct<T = unknown, S = unknown> {\n  readonly TYPE!: T\n  type: string\n  schema: S\n  coercer: (value: unknown, context: Context) => unknown\n  validator: (value: unknown, context: Context) => Iterable<Failure>\n  refiner: (value: T, context: Context) => Iterable<Failure>\n  entries: (\n    value: unknown,\n    context: Context\n  ) => Iterable<[string | number, unknown, Struct<any> | Struct<never>]>\n\n  constructor(props: {\n    type: string\n    schema: S\n    coercer?: Coercer\n    validator?: Validator\n    refiner?: Refiner<T>\n    entries?: Struct<T, S>['entries']\n  }) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = (value: unknown) => value,\n      entries = function* () {},\n    } = props\n\n    this.type = type\n    this.schema = schema\n    this.entries = entries\n    this.coercer = coercer\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context)\n        return toFailures(result, context, this, value)\n      }\n    } else {\n      this.validator = () => []\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context)\n        return toFailures(result, context, this, value)\n      }\n    } else {\n      this.refiner = () => []\n    }\n  }\n\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n  assert(value: unknown): asserts value is T {\n    return assert(value, this)\n  }\n\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n  create(value: unknown): T {\n    return create(value, this)\n  }\n\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n  is(value: unknown): value is T {\n    return is(value, this)\n  }\n\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n  mask(value: unknown): T {\n    return mask(value, this)\n  }\n\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n  validate(\n    value: unknown,\n    options: {\n      coerce?: boolean\n    } = {}\n  ): [StructError, undefined] | [undefined, T] {\n    return validate(value, this, options)\n  }\n}\n\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\nexport function assert<T, S>(\n  value: unknown,\n  struct: Struct<T, S>\n): asserts value is T {\n  const result = validate(value, struct)\n\n  if (result[0]) {\n    throw result[0]\n  }\n}\n\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\nexport function create<T, S>(value: unknown, struct: Struct<T, S>): T {\n  const result = validate(value, struct, { coerce: true })\n\n  if (result[0]) {\n    throw result[0]\n  } else {\n    return result[1]\n  }\n}\n\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\nexport function mask<T, S>(value: unknown, struct: Struct<T, S>): T {\n  const result = validate(value, struct, { coerce: true, mask: true })\n\n  if (result[0]) {\n    throw result[0]\n  } else {\n    return result[1]\n  }\n}\n\n/**\n * Check if a value passes a struct.\n */\n\nexport function is<T, S>(value: unknown, struct: Struct<T, S>): value is T {\n  const result = validate(value, struct)\n  return !result[0]\n}\n\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\nexport function validate<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  options: {\n    coerce?: boolean\n    mask?: boolean\n  } = {}\n): [StructError, undefined] | [undefined, T] {\n  const tuples = run(value, struct, options)\n  const tuple = shiftIterator(tuples)!\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0]\n        }\n      }\n    })\n\n    return [error, undefined]\n  } else {\n    const v = tuple[1]\n    return [undefined, v]\n  }\n}\n\n/**\n * A `Context` contains information about the current location of the\n * validation inside the initial input value.\n */\n\nexport type Context = {\n  branch: Array<any>\n  path: Array<any>\n}\n\n/**\n * A type utility to extract the type from a `Struct` class.\n */\n\nexport type Infer<T extends Struct<any, any>> = T['TYPE']\n\n/**\n * A type utility to describe that a struct represents a TypeScript type.\n */\n\nexport type Describe<T> = Struct<T, StructSchema<T>>\n\n/**\n * A `Result` is returned from validation functions.\n */\n\nexport type Result =\n  | boolean\n  | string\n  | Partial<Failure>\n  | Iterable<boolean | string | Partial<Failure>>\n\n/**\n * A `Coercer` takes an unknown value and optionally coerces it.\n */\n\nexport type Coercer<T = unknown> = (value: T, context: Context) => unknown\n\n/**\n * A `Validator` takes an unknown value and validates it.\n */\n\nexport type Validator = (value: unknown, context: Context) => Result\n\n/**\n * A `Refiner` takes a value of a known type and validates it against a further\n * constraint.\n */\n\nexport type Refiner<T> = (value: T, context: Context) => Result\n","import { Struct, Context, Validator } from '../struct'\nimport { object, optional, type } from './types'\nimport { ObjectSchema, Assign, ObjectType, PartialObjectSchema } from '../utils'\n\n/**\n * Create a new struct that combines the properties properties from multiple\n * object or type structs. Its return type will match the first parameter's type.\n *\n * Like JavaScript's `Object.assign` utility.\n */\n\nexport function assign<A extends ObjectSchema, B extends ObjectSchema>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>\n): Struct<ObjectType<Assign<A, B>>, Assign<A, B>>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>\n): Struct<ObjectType<Assign<Assign<A, B>, C>>, Assign<Assign<A, B>, C>>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema,\n  D extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>,\n  D: Struct<ObjectType<D>, D>\n): Struct<\n  ObjectType<Assign<Assign<Assign<A, B>, C>, D>>,\n  Assign<Assign<Assign<A, B>, C>, D>\n>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema,\n  D extends ObjectSchema,\n  E extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>,\n  D: Struct<ObjectType<D>, D>,\n  E: Struct<ObjectType<E>, E>\n): Struct<\n  ObjectType<Assign<Assign<Assign<Assign<A, B>, C>, D>, E>>,\n  Assign<Assign<Assign<Assign<A, B>, C>, D>, E>\n>\nexport function assign(...Structs: Struct<any>[]): any {\n  const isType = Structs[0].type === 'type'\n  const schemas = Structs.map((s) => s.schema)\n  const schema = Object.assign({}, ...schemas)\n  return isType ? type(schema) : object(schema)\n}\n\n/**\n * Define a new struct type with a custom validation function.\n */\n\nexport function define<T>(name: string, validator: Validator): Struct<T, null> {\n  return new Struct({ type: name, schema: null, validator })\n}\n\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\n\nexport function deprecated<T>(\n  struct: Struct<T>,\n  log: (value: unknown, ctx: Context) => void\n): Struct<T> {\n  return new Struct({\n    ...struct,\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true\n      } else {\n        log(value, ctx)\n        return struct.validator(value, ctx)\n      }\n    },\n  })\n}\n\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\nexport function dynamic<T>(\n  fn: (value: unknown, ctx: Context) => Struct<T, any>\n): Struct<T, null> {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    *entries(value, ctx) {\n      const struct = fn(value, ctx)\n      yield* struct.entries(value, ctx)\n    },\n    validator(value, ctx) {\n      const struct = fn(value, ctx)\n      return struct.validator(value, ctx)\n    },\n    coercer(value, ctx) {\n      const struct = fn(value, ctx)\n      return struct.coercer(value, ctx)\n    },\n    refiner(value, ctx) {\n      const struct = fn(value, ctx)\n      return struct.refiner(value, ctx)\n    },\n  })\n}\n\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\nexport function lazy<T>(fn: () => Struct<T, any>): Struct<T, null> {\n  let struct: Struct<T, any> | undefined\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    *entries(value, ctx) {\n      struct ??= fn()\n      yield* struct.entries(value, ctx)\n    },\n    validator(value, ctx) {\n      struct ??= fn()\n      return struct.validator(value, ctx)\n    },\n    coercer(value, ctx) {\n      struct ??= fn()\n      return struct.coercer(value, ctx)\n    },\n    refiner(value, ctx) {\n      struct ??= fn()\n      return struct.refiner(value, ctx)\n    },\n  })\n}\n\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\nexport function omit<S extends ObjectSchema, K extends keyof S>(\n  struct: Struct<ObjectType<S>, S>,\n  keys: K[]\n): Struct<ObjectType<Omit<S, K>>, Omit<S, K>> {\n  const { schema } = struct\n  const subschema: any = { ...schema }\n\n  for (const key of keys) {\n    delete subschema[key]\n  }\n\n  switch (struct.type) {\n    case 'type':\n      return type(subschema as Omit<S, K>)\n    default:\n      return object(subschema as Omit<S, K>)\n  }\n}\n\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\nexport function partial<S extends ObjectSchema>(\n  struct: Struct<ObjectType<S>, S> | S\n): Struct<ObjectType<PartialObjectSchema<S>>, PartialObjectSchema<S>> {\n  const schema: any =\n    struct instanceof Struct ? { ...struct.schema } : { ...struct }\n\n  for (const key in schema) {\n    schema[key] = optional(schema[key])\n  }\n\n  return object(schema) as any\n}\n\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\nexport function pick<S extends ObjectSchema, K extends keyof S>(\n  struct: Struct<ObjectType<S>, S>,\n  keys: K[]\n): Struct<ObjectType<Pick<S, K>>, Pick<S, K>> {\n  const { schema } = struct\n  const subschema: any = {}\n\n  for (const key of keys) {\n    subschema[key] = schema[key]\n  }\n\n  return object(subschema as Pick<S, K>)\n}\n\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\nexport function struct<T>(name: string, validator: Validator): Struct<T, null> {\n  console.warn(\n    'superstruct@0.11 - The `struct` helper has been renamed to `define`.'\n  )\n\n  return define(name, validator)\n}\n","import { Infer, Struct } from '../struct'\nimport { define } from './utilities'\nimport {\n  ObjectSchema,\n  ObjectType,\n  print,\n  run,\n  isObject,\n  AnyStruct,\n  InferStructTuple,\n  UnionToIntersection,\n} from '../utils'\n\n/**\n * Ensure that any value passes validation.\n */\n\nexport function any(): Struct<any, null> {\n  return define('any', () => true)\n}\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n */\n\nexport function array<T extends Struct<any>>(Element: T): Struct<Infer<T>[], T>\nexport function array(): Struct<unknown[], undefined>\nexport function array<T extends Struct<any>>(Element?: T): any {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element]\n        }\n      }\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array value, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a bigint.\n */\n\nexport function bigint(): Struct<bigint, null> {\n  return define('bigint', (value) => {\n    return typeof value === 'bigint'\n  })\n}\n\n/**\n * Ensure that a value is a boolean.\n */\n\nexport function boolean(): Struct<boolean, null> {\n  return define('boolean', (value) => {\n    return typeof value === 'boolean'\n  })\n}\n\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nexport function date(): Struct<Date, null> {\n  return define('date', (value) => {\n    return (\n      (value instanceof Date && !isNaN(value.getTime())) ||\n      `Expected a valid \\`Date\\` object, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n */\n\nexport function enums<T extends number>(\n  values: readonly T[]\n): Struct<T, { [K in T[][number]]: K }>\nexport function enums<T extends string>(\n  values: readonly T[]\n): Struct<T, { [K in T[][number]]: K }>\nexport function enums<T extends number | string>(values: readonly T[]): any {\n  const schema: any = {}\n  const description = values.map((v) => print(v)).join()\n\n  for (const key of values) {\n    schema[key] = key\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n    validator(value) {\n      return (\n        values.includes(value as any) ||\n        `Expected one of \\`${description}\\`, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a function.\n */\n\nexport function func(): Struct<Function, null> {\n  return define('func', (value) => {\n    return (\n      typeof value === 'function' ||\n      `Expected a function, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\nexport function instance<T extends { new (...args: any): any }>(\n  Class: T\n): Struct<InstanceType<T>, null> {\n  return define('instance', (value) => {\n    return (\n      value instanceof Class ||\n      `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an integer.\n */\n\nexport function integer(): Struct<number, null> {\n  return define('integer', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n      `Expected an integer, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value matches all of a set of types.\n */\n\nexport function intersection<A extends AnyStruct, B extends AnyStruct[]>(\n  Structs: [A, ...B]\n): Struct<Infer<A> & UnionToIntersection<InferStructTuple<B>[number]>, null> {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx)\n      }\n    },\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx)\n      }\n    },\n    *refiner(value, ctx) {\n      for (const S of Structs) {\n        yield* S.refiner(value, ctx)\n      }\n    },\n  })\n}\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n */\n\nexport function literal<T extends boolean>(constant: T): Struct<T, T>\nexport function literal<T extends number>(constant: T): Struct<T, T>\nexport function literal<T extends string>(constant: T): Struct<T, T>\nexport function literal<T>(constant: T): Struct<T, null>\nexport function literal<T>(constant: T): any {\n  const description = print(constant)\n  const t = typeof constant\n  return new Struct({\n    type: 'literal',\n    schema:\n      t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n    validator(value) {\n      return (\n        value === constant ||\n        `Expected the literal \\`${description}\\`, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n */\n\nexport function map(): Struct<Map<unknown, unknown>, null>\nexport function map<K, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Map<K, V>, null>\nexport function map<K, V>(Key?: Struct<K>, Value?: Struct<V>): any {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k as string, k, Key]\n          yield [k as string, v, Value]\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value\n    },\n    validator(value) {\n      return (\n        value instanceof Map ||\n        `Expected a \\`Map\\` object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that no value ever passes validation.\n */\n\nexport function never(): Struct<never, null> {\n  return define('never', () => false)\n}\n\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nexport function nullable<T, S>(struct: Struct<T, S>): Struct<T | null, S> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n  })\n}\n\n/**\n * Ensure that a value is a number.\n */\n\nexport function number(): Struct<number, null> {\n  return define('number', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value)) ||\n      `Expected a number, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an object, that is has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n */\n\nexport function object(): Struct<Record<string, unknown>, null>\nexport function object<S extends ObjectSchema>(\n  schema: S\n): Struct<ObjectType<S>, S>\nexport function object<S extends ObjectSchema>(schema?: S): any {\n  const knowns = schema ? Object.keys(schema) : []\n  const Never = never()\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value))\n\n        for (const key of knowns) {\n          unknowns.delete(key)\n          yield [key, value[key], schema[key]]\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n    coercer(value) {\n      return isObject(value) ? { ...value } : value\n    },\n  })\n}\n\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nexport function optional<T, S>(struct: Struct<T, S>): Struct<T | undefined, S> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) =>\n      value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n  })\n}\n\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\nexport function record<K extends string, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Record<K, V>, null> {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k]\n          yield [k, k, Key]\n          yield [k, v, Value]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\nexport function regexp(): Struct<RegExp, null> {\n  return define('regexp', (value) => {\n    return value instanceof RegExp\n  })\n}\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n */\n\nexport function set(): Struct<Set<unknown>, null>\nexport function set<T>(Element: Struct<T>): Struct<Set<T>, null>\nexport function set<T>(Element?: Struct<T>): any {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v as string, v, Element]\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value\n    },\n    validator(value) {\n      return (\n        value instanceof Set ||\n        `Expected a \\`Set\\` object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a string.\n */\n\nexport function string(): Struct<string, null> {\n  return define('string', (value) => {\n    return (\n      typeof value === 'string' ||\n      `Expected a string, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\n\nexport function tuple<A extends AnyStruct, B extends AnyStruct[]>(\n  Structs: [A, ...B]\n): Struct<[Infer<A>, ...InferStructTuple<B>], null> {\n  const Never = never()\n\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Structs.length, value.length)\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Structs[i] || Never]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nexport function type<S extends ObjectSchema>(\n  schema: S\n): Struct<ObjectType<S>, S> {\n  const keys = Object.keys(schema)\n  return new Struct({\n    type: 'type',\n    schema,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value matches one of a set of types.\n */\n\nexport function union<A extends AnyStruct, B extends AnyStruct[]>(\n  Structs: [A, ...B]\n): Struct<Infer<A> | InferStructTuple<B>[number], null> {\n  const description = Structs.map((s) => s.type).join(' | ')\n  return new Struct({\n    type: 'union',\n    schema: null,\n    coercer(value, ctx) {\n      const firstMatch =\n        Structs.find((s) => {\n          const [e] = s.validate(value, { coerce: true })\n          return !e\n        }) || unknown()\n      return firstMatch.coercer(value, ctx)\n    },\n    validator(value, ctx) {\n      const failures = []\n\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx)\n        const [first] = tuples\n\n        if (!first[0]) {\n          return []\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure)\n            }\n          }\n        }\n      }\n\n      return [\n        `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(\n          value\n        )}`,\n        ...failures,\n      ]\n    },\n  })\n}\n\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nexport function unknown(): Struct<unknown, null> {\n  return define('unknown', () => true)\n}\n","import { Struct, is, Coercer } from '../struct'\nimport { isPlainObject } from '../utils'\nimport { string, unknown } from './types'\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function coerce<T, S, C>(\n  struct: Struct<T, S>,\n  condition: Struct<C, any>,\n  coercer: Coercer<C>\n): Struct<T, S> {\n  return new Struct({\n    ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition)\n        ? struct.coercer(coercer(value, ctx), ctx)\n        : struct.coercer(value, ctx)\n    },\n  })\n}\n\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function defaulted<T, S>(\n  struct: Struct<T, S>,\n  fallback: any,\n  options: {\n    strict?: boolean\n  } = {}\n): Struct<T, S> {\n  return coerce(struct, unknown(), (x) => {\n    const f = typeof fallback === 'function' ? fallback() : fallback\n\n    if (x === undefined) {\n      return f\n    }\n\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x }\n      let changed = false\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key]\n          changed = true\n        }\n      }\n\n      if (changed) {\n        return ret\n      }\n    }\n\n    return x\n  })\n}\n\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function trimmed<T, S>(struct: Struct<T, S>): Struct<T, S> {\n  return coerce(struct, string(), (x) => x.trim())\n}\n","import { Struct, Refiner } from '../struct'\nimport { toFailures } from '../utils'\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\nexport function empty<\n  T extends string | any[] | Map<any, any> | Set<any>,\n  S extends any\n>(struct: Struct<T, S>): Struct<T, S> {\n  return refine(struct, 'empty', (value) => {\n    const size = getSize(value)\n    return (\n      size === 0 ||\n      `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``\n    )\n  })\n}\n\nfunction getSize(value: string | any[] | Map<any, any> | Set<any>): number {\n  if (value instanceof Map || value instanceof Set) {\n    return value.size\n  } else {\n    return value.length\n  }\n}\n\n/**\n * Ensure that a number or date is below a threshold.\n */\n\nexport function max<T extends number | Date, S extends any>(\n  struct: Struct<T, S>,\n  threshold: T,\n  options: {\n    exclusive?: boolean\n  } = {}\n): Struct<T, S> {\n  const { exclusive } = options\n  return refine(struct, 'max', (value) => {\n    return exclusive\n      ? value < threshold\n      : value <= threshold ||\n          `Expected a ${struct.type} less than ${\n            exclusive ? '' : 'or equal to '\n          }${threshold} but received \\`${value}\\``\n  })\n}\n\n/**\n * Ensure that a number or date is above a threshold.\n */\n\nexport function min<T extends number | Date, S extends any>(\n  struct: Struct<T, S>,\n  threshold: T,\n  options: {\n    exclusive?: boolean\n  } = {}\n): Struct<T, S> {\n  const { exclusive } = options\n  return refine(struct, 'min', (value) => {\n    return exclusive\n      ? value > threshold\n      : value >= threshold ||\n          `Expected a ${struct.type} greater than ${\n            exclusive ? '' : 'or equal to '\n          }${threshold} but received \\`${value}\\``\n  })\n}\n\n/**\n * Ensure that a string, array, map or set is not empty.\n */\n\nexport function nonempty<\n  T extends string | any[] | Map<any, any> | Set<any>,\n  S extends any\n>(struct: Struct<T, S>): Struct<T, S> {\n  return refine(struct, 'nonempty', (value) => {\n    const size = getSize(value)\n    return (\n      size > 0 || `Expected a nonempty ${struct.type} but received an empty one`\n    )\n  })\n}\n\n/**\n * Ensure that a string matches a regular expression.\n */\n\nexport function pattern<T extends string, S extends any>(\n  struct: Struct<T, S>,\n  regexp: RegExp\n): Struct<T, S> {\n  return refine(struct, 'pattern', (value) => {\n    return (\n      regexp.test(value) ||\n      `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`\n    )\n  })\n}\n\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\nexport function size<\n  T extends string | number | Date | any[] | Map<any, any> | Set<any>,\n  S extends any\n>(struct: Struct<T, S>, min: number, max: number = min): Struct<T, S> {\n  const expected = `Expected a ${struct.type}`\n  const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``\n\n  return refine(struct, 'size', (value) => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return (\n        (min <= value && value <= max) ||\n        `${expected} ${of} but received \\`${value}\\``\n      )\n    } else if (value instanceof Map || value instanceof Set) {\n      const { size } = value\n      return (\n        (min <= size && size <= max) ||\n        `${expected} with a size ${of} but received one with a size of \\`${size}\\``\n      )\n    } else {\n      const { length } = value as string | any[]\n      return (\n        (min <= length && length <= max) ||\n        `${expected} with a length ${of} but received one with a length of \\`${length}\\``\n      )\n    }\n  })\n}\n\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\nexport function refine<T, S>(\n  struct: Struct<T, S>,\n  name: string,\n  refiner: Refiner<T>\n): Struct<T, S> {\n  return new Struct({\n    ...struct,\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx)\n      const result = refiner(value, ctx)\n      const failures = toFailures(result, ctx, struct, value)\n\n      for (const failure of failures) {\n        yield { ...failure, refinement: name }\n      }\n    },\n  })\n}\n"]},"metadata":{},"sourceType":"module"}